// SPDX-License-Identifier: MIT
#![no_main]

use rkyv::{AlignedVec, Deserialize};
use risc0_zkvm::guest::env;

use bridge_logic::db::MutableMemDB;
use bridge_logic::executor::sim_exploit_with_inspector;
use bridge_logic::hardfork::spec_id_from_chain;
use bridge_logic::state_diff::compute_state_diff;
use bridge_types::conversions::fixed_to_u256;
use bridge_types::mpt::{verify_account_proof, verify_storage_proof};
use bridge_types::types::{compute_assertions_hash, compute_deals_hash, Assertion, ExploitInput, ExploitJournal};

use alloy_primitives::{Address, Bytes, U256};
use revm::primitives::{AccountInfo, Bytecode, KECCAK_EMPTY, EvmState};
use revm::{Inspector, EvmContext};
use revm::db::Database;
use revm::interpreter::{CallInputs, CallOutcome, CreateInputs, CreateOutcome, CallScheme, CreateScheme};

risc0_zkvm::guest::entry!(main);

fn main() {
    // Set up panic hook to capture panics in the journal
    std::panic::set_hook(Box::new(|info| {
        let msg = format!("Guest panicked: {info}");
        let empty_diff = bridge_types::types::StateDiff(std::collections::BTreeMap::new());
        let journal = ExploitJournal {
            success: false,
            gas_used: 0,
            deals_hash: [0; 32],
            assertions_hash: [0; 32],
            assertions_ok: false,
            nonce: [0; 32],
            caller: [0; 20],
            contract_address: [0; 20],
            call_trace_hash: [0; 32],
            exit_reason: msg,
            state_root: [0; 32],
            block_number: 0,
            chain_id: 0,
            timestamp: 0,
            basefee: [0; 32],
            block_gas_limit: 0,
            poc_code_hash: [0; 32],
            state_diff: empty_diff,
            call_trace_enabled: false,
            state_diff_enabled: false,
        };
        env::commit(&journal);
    }));

    // Read input from host (raw rkyv bytes, no compression)
    let raw_input: Vec<u8> = env::read();

    // Copy to AlignedVec for rkyv alignment safety
    // (env::read returns Vec<u8> which might not be 16-byte aligned, though usually is.
    // copying is safer and cheap compared to decompression)
    let mut raw_bytes = AlignedVec::new();
    raw_bytes.extend_from_slice(&raw_input);

    // Validate and deserialize rkyv
    let archived = rkyv::check_archived_root::<ExploitInput>(&raw_bytes)
        .expect("rkyv validation failed");
    let input: ExploitInput = archived
        .deserialize(&mut rkyv::Infallible)
        .expect("rkyv deserialization failed");

    // Compute deals hash
    let deals_hash = compute_deals_hash(&input.deals);
    let assertions_hash = compute_assertions_hash(&input.assertions);
    let nonce = input.nonce;

    // Extract state commitment values
    let state_root = input.env.state_root;
    let block_number = input.env.number;
    let chain_id = input.env.chain_id;
    let timestamp = input.env.timestamp;
    let block_gas_limit = input.env.gas_limit;
    let basefee = input.env.basefee;
    
    // Compute PoC code hash
    let poc_code_hash = alloy_primitives::keccak256(&input.poc_bytecode).0;

    // --- State Proof Verification ---
    // Build a map of addresses to proofs for fast lookups.
    let mut proofs_by_addr = std::collections::BTreeMap::new();
    for proof in &input.proofs {
        proofs_by_addr.insert(proof.address, proof);
    }

    // Verify ALL real accounts/storage in original_db have proofs
    let caller_addr_fixed: [u8; 20] = input.caller;
    
    // Ensure the contract address is empty and proven in the real chain state.
    ensure_synthetic_empty(&input.original_db, &input.contract_address, "contract");
    ensure_contract_proven(&input.original_db, &proofs_by_addr, &input.contract_address);

    for (addr, db_account) in &input.original_db.accounts {
        if *addr == caller_addr_fixed {
            continue; // Skip synthetic caller account
        }
        
        // Critical Fix: Ensure account exists in proofs
        let proof = match proofs_by_addr.get(addr) {
            Some(p) => p,
            None => panic!("account 0x{} in original_db has no proof", hex_addr(addr)),
        };

        // Critical Fix: Ensure all DB storage slots are covered by the proof
        let proven_slots: std::collections::BTreeSet<[u8; 32]> = proof
            .storage_proofs
            .iter()
            .map(|sp| sp.key)
            .collect();

        for slot_key in db_account.storage.keys() {
            assert!(
                proven_slots.contains(slot_key),
                "storage slot 0x{} on account 0x{} in original_db has no proof",
                alloy_primitives::hex::encode(slot_key),
                hex_addr(addr)
            );
        }
    }

    // Verify each proof against state_root and cross-check with original_db
    for proof in &input.proofs {
        let proven = verify_account_proof(state_root, &proof.address, &proof.account_proof)
            .unwrap_or_else(|e| panic!(
                "account proof failed for 0x{}: {}",
                hex_addr(&proof.address), e
            ));

        match proven {
            Some(p) => {
                // Cross-check proven values match the proof struct itself
                assert_eq!(p.nonce, proof.nonce, "nonce mismatch in proof");
                assert_eq!(p.balance, proof.balance, "balance mismatch in proof");
                assert_eq!(p.storage_root, proof.storage_hash, "storage_hash mismatch in proof");
                assert_eq!(p.code_hash, proof.code_hash, "code_hash mismatch in proof");
            },
            None => {
                // Non-existent account: verify the proof struct shows empty state
                assert_eq!(proof.nonce, 0, "non-existent account should have nonce 0");
                assert_eq!(proof.balance, [0u8; 32], "non-existent account should have zero balance");
                
                // Critical Fix: Proof of Absence Injection
                if let Some(db_account) = input.original_db.accounts.get(&proof.address) {
                    assert_eq!(db_account.nonce, 0, "db account mismatch for absent account");
                    assert_eq!(db_account.balance, [0u8; 32], "db balance mismatch for absent account");
                    assert_eq!(db_account.code_hash, KECCAK_EMPTY.0, "db code_hash mismatch for absent account");
                    assert!(db_account.storage.is_empty(), "db storage mismatch for absent account");
                }
                continue;
            }
        };

        // Cross-check with original_db if the account exists there
        if let Some(db_account) = input.original_db.accounts.get(&proof.address) {
            if proof.address != caller_addr_fixed {
                assert_eq!(db_account.nonce, proof.nonce, "original_db nonce mismatch");
                assert_eq!(db_account.balance, proof.balance, "original_db balance mismatch");
                assert_eq!(db_account.code_hash, proof.code_hash, "original_db code_hash mismatch");
            }
        }

        // Verify each storage proof
        for sp in &proof.storage_proofs {
            let proven_value = verify_storage_proof(proof.storage_hash, &sp.key, &sp.proof)
                .expect("storage proof verification failed");
            
            assert_eq!(proven_value, sp.value, "proven storage value mismatch");

            // Cross-check value is done implicitly by the fact that we checked the DB slots exist in proof
            // But we should check value match too:
            if let Some(db_account) = input.original_db.accounts.get(&proof.address) {
                if let Some(db_value) = db_account.storage.get(&sp.key) {
                    assert_eq!(*db_value, sp.value, "original_db storage value mismatch");
                }
            }
        }
    }

    // --- Code Hash Verification ---
    for (addr, account) in &input.original_db.accounts {
        if *addr == caller_addr_fixed {
            continue;
        }
        let code_hash_fixed = account.code_hash;
        if code_hash_fixed != KECCAK_EMPTY.0 {
            let code_bytes = account.code.as_ref().unwrap_or_else(|| {
                panic!("account 0x{} has non-empty code_hash but no code provided", hex_addr(addr))
            });
            let hash = alloy_primitives::keccak256(code_bytes);
            assert_eq!(hash.0, code_hash_fixed, "code hash mismatch");
        } else if let Some(code) = &account.code {
            assert!(code.is_empty(), "account 0x{} has empty code_hash but non-empty code", hex_addr(addr));
        }
    }

    // Build mutable DB
    let mut db = MutableMemDB::from_rkyv_strict(input.original_db.clone());

    // Inject PoC contract and Caller
    let contract_addr = Address::from(input.contract_address);
    let poc_bytecode = Bytecode::new_raw(Bytes::copy_from_slice(&input.poc_bytecode));
    db.codes.insert(alloy_primitives::B256::from(poc_code_hash), Bytes::copy_from_slice(&input.poc_bytecode));
    db.accounts.insert(
        contract_addr,
        AccountInfo {
            balance: U256::ZERO,
            nonce: 1,
            code_hash: alloy_primitives::B256::from(poc_code_hash),
            code: Some(poc_bytecode),
        },
    );
    db.allow_missing_storage_for(contract_addr);

    let caller_addr = Address::from(input.caller);
    db.accounts.insert(
        caller_addr,
        AccountInfo {
            balance: U256::from(1_000_000_000_000_000_000u128),
            nonce: 0,
            code_hash: KECCAK_EMPTY,
            code: Some(Bytecode::default()),
        },
    );
    db.allow_missing_storage_for(caller_addr);

    // Apply deals
    db.apply_deals(&input.deals);

    // Execute with optional call trace inspector
    let spec_id = spec_id_from_chain(input.env.chain_id, input.env.timestamp);
    let (result, call_trace_hash, blockhash_used) = if input.options.enable_call_trace {
        let (result, inspector) = sim_exploit_with_inspector(
            db,
            &input.env,
            &input.poc_bytecode,
            input.gas_limit,
            caller_addr,
            contract_addr,
            spec_id,
            CallTraceInspector::new(),
        );
        (result, inspector.trace_hash(), inspector.blockhash_used())
    } else {
        let (result, inspector) = sim_exploit_with_inspector(
            db,
            &input.env,
            &input.poc_bytecode,
            input.gas_limit,
            caller_addr,
            contract_addr,
            spec_id,
            BlockhashInspector::new(),
        );
        (result, [0u8; 32], inspector.blockhash_used())
    };

    let journal = match result {
        Ok(result_and_state) => {
            let state_diff = if input.options.enable_state_diff {
                compute_state_diff(&result_and_state.state, &input.original_db)
            } else {
                bridge_types::types::StateDiff(std::collections::BTreeMap::new())
            };
            let mut exit_reason = match &result_and_state.result {
                revm::primitives::ExecutionResult::Success { .. } => "Success".to_string(),
                revm::primitives::ExecutionResult::Revert { output, .. } => format!("Revert: {}", String::from_utf8_lossy(output)),
                revm::primitives::ExecutionResult::Halt { reason, .. } => format!("Halt: {:?}", reason),
            };
            let success = result_and_state.result.is_success();
            let gas_used = result_and_state.result.gas_used();

            let mut assertions_ok = true;
            if blockhash_used {
                assertions_ok = false;
                exit_reason = "BLOCKHASH opcode is not supported in zkpoex proofs".to_string();
            } else if let Err(err) = check_assertions(
                &input.assertions,
                &input.original_db,
                &proofs_by_addr,
                &result_and_state.state,
                &input.deals,
                &input.caller,
            ) {
                assertions_ok = false;
                exit_reason = format!("Assertion failed: {err}");
            }

            ExploitJournal {
                success: success && !blockhash_used,
                gas_used,
                deals_hash,
                assertions_hash,
                assertions_ok,
                nonce,
                caller: input.caller,
                contract_address: input.contract_address,
                call_trace_hash,
                exit_reason,
                state_root,
                block_number,
                chain_id,
                timestamp,
                basefee,
                block_gas_limit,
                poc_code_hash,
                state_diff,
                call_trace_enabled: input.options.enable_call_trace,
                state_diff_enabled: input.options.enable_state_diff,
            }
        },
        Err(e) => {
            let empty_diff = bridge_types::types::StateDiff(std::collections::BTreeMap::new());
            let exit_reason = if blockhash_used {
                "BLOCKHASH opcode is not supported in zkpoex proofs".to_string()
            } else {
                format!("Error: {e}")
            };
            ExploitJournal {
                success: false,
                gas_used: 0,
                deals_hash,
                assertions_hash,
                assertions_ok: false,
                nonce,
                caller: input.caller,
                contract_address: input.contract_address,
                call_trace_hash,
                exit_reason,
                state_root,
                block_number,
                chain_id,
                timestamp,
                basefee,
                block_gas_limit,
                poc_code_hash,
                state_diff: empty_diff,
                call_trace_enabled: input.options.enable_call_trace,
                state_diff_enabled: input.options.enable_state_diff,
            }
        },
    };

    env::commit(&journal);
}

/// Format an address as hex for error messages (no alloc-heavy dependencies).
fn hex_addr(addr: &[u8; 20]) -> String {
    addr.iter().map(|b| format!("{b:02x}")).collect()
}

fn ensure_synthetic_empty(
    original_db: &bridge_types::types::RkyvMemDB,
    address: &[u8; 20],
    label: &str,
) {
    let Some(account) = original_db.accounts.get(address) else {
        return;
    };
    let has_balance = account.balance != [0u8; 32];
    let has_nonce = account.nonce != 0;
    let has_code_hash = account.code_hash != KECCAK_EMPTY.0;
    let has_code = account.code.as_ref().map(|c| !c.is_empty()).unwrap_or(false);
    let has_storage = !account.storage.is_empty();

    assert!(
        !(has_balance || has_nonce || has_code_hash || has_code || has_storage),
        "{label} synthetic address 0x{} is non-empty in chain state; choose a different synthetic address",
        hex_addr(address)
    );
}

fn ensure_contract_proven(
    original_db: &bridge_types::types::RkyvMemDB,
    proofs_by_addr: &std::collections::BTreeMap<
        [u8; 20],
        &bridge_types::types::EIP1186AccountProof,
    >,
    address: &[u8; 20],
) {
    assert!(
        original_db.accounts.contains_key(address),
        "contract address 0x{} not present in proven pre-state",
        hex_addr(address)
    );
    assert!(
        proofs_by_addr.contains_key(address),
        "contract address 0x{} has no proof",
        hex_addr(address)
    );
}

struct CallTraceInspector {
    trace_hash: [u8; 32],
    blockhash_used: bool,
}

impl CallTraceInspector {
    fn new() -> Self {
        Self {
            trace_hash: alloy_primitives::keccak256([]).0,
            blockhash_used: false,
        }
    }

    fn trace_hash(&self) -> [u8; 32] {
        self.trace_hash
    }

    fn blockhash_used(&self) -> bool {
        self.blockhash_used
    }

    fn absorb(&mut self, item_hash: [u8; 32]) {
        let mut buf = [0u8; 64];
        buf[..32].copy_from_slice(&self.trace_hash);
        buf[32..].copy_from_slice(&item_hash);
        self.trace_hash = alloy_primitives::keccak256(buf).0;
    }
}

struct BlockhashInspector {
    blockhash_used: bool,
}

impl BlockhashInspector {
    fn new() -> Self {
        Self {
            blockhash_used: false,
        }
    }

    fn blockhash_used(&self) -> bool {
        self.blockhash_used
    }
}

impl<DB: Database> Inspector<DB> for CallTraceInspector {
    fn step(&mut self, interp: &mut revm::interpreter::Interpreter, _context: &mut EvmContext<DB>) {
        if interp.current_opcode() == 0x40 {
            self.blockhash_used = true;
        }
    }

    fn call(
        &mut self,
        _context: &mut EvmContext<DB>,
        inputs: &mut CallInputs,
    ) -> Option<CallOutcome> {
        let item_hash = hash_call_inputs(inputs);
        self.absorb(item_hash);
        None
    }

    fn create(
        &mut self,
        _context: &mut EvmContext<DB>,
        inputs: &mut CreateInputs,
    ) -> Option<CreateOutcome> {
        let item_hash = hash_create_inputs(inputs);
        self.absorb(item_hash);
        None
    }
}

impl<DB: Database> Inspector<DB> for BlockhashInspector {
    fn step(&mut self, interp: &mut revm::interpreter::Interpreter, _context: &mut EvmContext<DB>) {
        if interp.current_opcode() == 0x40 {
            self.blockhash_used = true;
        }
    }
}

fn hash_call_inputs(inputs: &CallInputs) -> [u8; 32] {
    // Fixed-size buffer avoids heap allocations inside the zkVM.
    let mut data = [0u8; 108];
    let mut offset = 0;
    data[offset] = 0x01;
    offset += 1;
    data[offset..offset + 20].copy_from_slice(inputs.caller.as_slice());
    offset += 20;
    data[offset..offset + 20].copy_from_slice(inputs.target_address.as_slice());
    offset += 20;
    data[offset..offset + 32].copy_from_slice(&inputs.call_value().to_be_bytes::<32>());
    offset += 32;
    let input_hash = alloy_primitives::keccak256(&inputs.input).0;
    data[offset..offset + 32].copy_from_slice(&input_hash);
    offset += 32;
    data[offset] = call_scheme_tag(inputs.scheme);
    offset += 1;
    data[offset] = inputs.is_static as u8;
    offset += 1;
    data[offset] = inputs.is_eof as u8;
    alloy_primitives::keccak256(data).0
}

fn hash_create_inputs(inputs: &CreateInputs) -> [u8; 32] {
    // Fixed-size buffer avoids heap allocations inside the zkVM.
    let mut data = [0u8; 118];
    let mut offset = 0;
    data[offset] = 0x02;
    offset += 1;
    data[offset..offset + 20].copy_from_slice(inputs.caller.as_slice());
    offset += 20;
    data[offset..offset + 32].copy_from_slice(&inputs.value.to_be_bytes::<32>());
    offset += 32;
    let init_hash = alloy_primitives::keccak256(&inputs.init_code).0;
    data[offset..offset + 32].copy_from_slice(&init_hash);
    offset += 32;
    match inputs.scheme {
        CreateScheme::Create => {
            data[offset] = 0x00;
            offset += 1;
        }
        CreateScheme::Create2 { salt } => {
            data[offset] = 0x01;
            offset += 1;
            data[offset..offset + 32].copy_from_slice(&salt.to_be_bytes::<32>());
            offset += 32;
        }
    }
    alloy_primitives::keccak256(&data[..offset]).0
}

fn call_scheme_tag(scheme: CallScheme) -> u8 {
    match scheme {
        CallScheme::Call => 0,
        CallScheme::CallCode => 1,
        CallScheme::DelegateCall => 2,
        CallScheme::StaticCall => 3,
        CallScheme::ExtCall => 4,
        CallScheme::ExtStaticCall => 5,
        CallScheme::ExtDelegateCall => 6,
    }
}

fn check_assertions(
    assertions: &[Assertion],
    original_db: &bridge_types::types::RkyvMemDB,
    proofs_by_addr: &std::collections::BTreeMap<
        [u8; 20],
        &bridge_types::types::EIP1186AccountProof,
    >,
    post_state: &EvmState,
    deals: &[bridge_types::types::DealRecord],
    caller: &[u8; 20],
) -> Result<(), String> {
    let mut caller_slot = [0u8; 32];
    caller_slot[12..].copy_from_slice(caller);
    let caller_u256 = fixed_to_u256(caller_slot);

    for assertion in assertions {
        match assertion {
            Assertion::NoDeals => {
                if !deals.is_empty() {
                    return Err("deals were applied".to_string());
                }
            }
            Assertion::Balance { address, from, to } => {
                ensure_account_proven(original_db, proofs_by_addr, address)?;
                let pre = get_pre_balance(original_db, address);
                let post = get_post_balance(original_db, post_state, address);
                let expected_from = fixed_to_u256(*from);
                let expected_to = fixed_to_u256(*to);
                if pre != expected_from || post != expected_to {
                    return Err(format!(
                        "balance mismatch for 0x{} (pre={}, post={}, expected_pre={}, expected_post={})",
                        hex_addr(address),
                        pre,
                        post,
                        expected_from,
                        expected_to
                    ));
                }
            }
            Assertion::Storage {
                address,
                slot,
                from,
                to,
            } => {
                ensure_slot_proven(original_db, proofs_by_addr, address, slot)?;
                let pre = get_pre_slot(original_db, address, slot);
                let post = get_post_slot(original_db, post_state, address, slot);
                let expected_from = fixed_to_u256(*from);
                let expected_to = fixed_to_u256(*to);
                if pre != expected_from || post != expected_to {
                    return Err(format!(
                        "storage mismatch for 0x{} slot 0x{} (pre={}, post={}, expected_pre={}, expected_post={})",
                        hex_addr(address),
                        alloy_primitives::hex::encode(slot),
                        pre,
                        post,
                        expected_from,
                        expected_to
                    ));
                }
            }
            Assertion::NotOwner { address, slot } => {
                ensure_slot_proven(original_db, proofs_by_addr, address, slot)?;
                let pre = get_pre_slot(original_db, address, slot);
                if pre == caller_u256 {
                    return Err(format!(
                        "not-owner failed: caller matches owner slot 0x{} on 0x{}",
                        alloy_primitives::hex::encode(slot),
                        hex_addr(address)
                    ));
                }
            }
        }
    }
    Ok(())
}

fn ensure_account_proven(
    original_db: &bridge_types::types::RkyvMemDB,
    proofs_by_addr: &std::collections::BTreeMap<
        [u8; 20],
        &bridge_types::types::EIP1186AccountProof,
    >,
    address: &[u8; 20],
) -> Result<(), String> {
    if !original_db.accounts.contains_key(address) {
        return Err(format!(
            "assertion target account 0x{} not present in proven pre-state",
            hex_addr(address)
        ));
    }
    if !proofs_by_addr.contains_key(address) {
        return Err(format!(
            "assertion target account 0x{} has no proof",
            hex_addr(address)
        ));
    }
    Ok(())
}

fn ensure_slot_proven(
    original_db: &bridge_types::types::RkyvMemDB,
    proofs_by_addr: &std::collections::BTreeMap<
        [u8; 20],
        &bridge_types::types::EIP1186AccountProof,
    >,
    address: &[u8; 20],
    slot: &[u8; 32],
) -> Result<(), String> {
    ensure_account_proven(original_db, proofs_by_addr, address)?;
    let account = original_db.accounts.get(address).ok_or_else(|| {
        format!(
            "assertion target account 0x{} missing in proven pre-state",
            hex_addr(address)
        )
    })?;
    if !account.storage.contains_key(slot) {
        return Err(format!(
            "assertion target slot 0x{} on 0x{} missing in proven pre-state",
            alloy_primitives::hex::encode(slot),
            hex_addr(address)
        ));
    }
    let proof = proofs_by_addr.get(address).ok_or_else(|| {
        format!(
            "assertion target account 0x{} has no proof",
            hex_addr(address)
        )
    })?;
    let slot_proven = proof.storage_proofs.iter().any(|sp| &sp.key == slot);
    if !slot_proven {
        return Err(format!(
            "assertion target slot 0x{} on 0x{} has no proof",
            alloy_primitives::hex::encode(slot),
            hex_addr(address)
        ));
    }
    Ok(())
}

fn get_pre_balance(
    original_db: &bridge_types::types::RkyvMemDB,
    address: &[u8; 20],
) -> U256 {
    original_db
        .accounts
        .get(address)
        .map(|acc| fixed_to_u256(acc.balance))
        .unwrap_or(U256::ZERO)
}

fn get_post_balance(
    original_db: &bridge_types::types::RkyvMemDB,
    post_state: &EvmState,
    address: &[u8; 20],
) -> U256 {
    let addr = Address::from(*address);
    if let Some(account) = post_state.get(&addr) {
        account.info.balance
    } else {
        get_pre_balance(original_db, address)
    }
}

fn get_pre_slot(
    original_db: &bridge_types::types::RkyvMemDB,
    address: &[u8; 20],
    slot: &[u8; 32],
) -> U256 {
    if let Some(account) = original_db.accounts.get(address) {
        if let Some(value) = account.storage.get(slot) {
            return fixed_to_u256(*value);
        }
    }
    U256::ZERO
}

fn get_post_slot(
    original_db: &bridge_types::types::RkyvMemDB,
    post_state: &EvmState,
    address: &[u8; 20],
    slot: &[u8; 32],
) -> U256 {
    let addr = Address::from(*address);
    let slot_u256 = fixed_to_u256(*slot);
    if let Some(account) = post_state.get(&addr) {
        if let Some(stored) = account.storage.get(&slot_u256) {
            return stored.present_value;
        }
    }
    get_pre_slot(original_db, address, slot)
}
